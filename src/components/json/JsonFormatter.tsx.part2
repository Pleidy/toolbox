  const [tabs, setTabs] = useState([
    { id: createId(), name: '标签 1', input: '', output: '', fontSize: 13, foldedLines: new Set() }
  ]);
  const [activeTabId, setActiveTabId] = useState(tabs[0].id);

  const activeTab = tabs.find(t => t.id === activeTabId) || tabs[0];

  const updateActiveTab = useCallback((updates) => {
    setTabs(prev => prev.map(t => 
      t.id === activeTabId ? { ...t, ...updates } : t
    ));
  }, [activeTabId]);

  const parseResult = useMemo(() => {
    if (!activeTab.input.trim()) return null;
    return parseJsonToTree(activeTab.input);
  }, [activeTab.input]);

  const flatNodes = useMemo(() => {
    if (!parseResult?.tree.length) return { nodes: [], lineCount: 0 };
    return flattenTree(parseResult.tree);
  }, [parseResult]);

  const toggleFold = useCallback((lineNumber) => {
    const newFolded = new Set(activeTab.foldedLines);
    if (newFolded.has(lineNumber)) {
      newFolded.delete(lineNumber);
    } else {
      newFolded.add(lineNumber);
    }
    updateActiveTab({ foldedLines: newFolded });
  }, [activeTab.foldedLines, updateActiveTab]);

  const isLineVisible = useCallback((lineNumber) => {
    let currentLine = lineNumber;
    while (currentLine > 0) {
      currentLine--;
      if (activeTab.foldedLines.has(currentLine)) {
        const foldedNode = flatNodes.nodes[currentLine];
        const currentNode = flatNodes.nodes[lineNumber];
        
        if (foldedNode && currentNode && foldedNode.indent !== undefined && currentNode.indent !== undefined) {
          if (currentNode.indent > foldedNode.indent) {
            return false;
          }
        }
      }
    }
    return true;
  }, [activeTab.foldedLines, flatNodes]);

  const handleFormat = useCallback(() => {
    if (parseResult?.error) {
      updateActiveTab({ output: 'Error: ' + parseResult.error });
      return;
    }
    if (!activeTab.input.trim()) {
      updateActiveTab({ output: '' });
      return;
    }
    try {
      const parsed = JSON.parse(activeTab.input);
      updateActiveTab({ output: JSON.stringify(parsed, null, 2) });
    } catch (e) {
      updateActiveTab({ output: 'Error: ' + e.message });
    }
  }, [activeTab.input, parseResult, updateActiveTab]);

  const handleCompress = useCallback(() => {
    if (parseResult?.error) {
      updateActiveTab({ output: 'Error: ' + parseResult.error });
      return;
    }
    if (!activeTab.input.trim()) {
      updateActiveTab({ output: '' });
      return;
    }
    try {
      const parsed = JSON.parse(activeTab.input);
      updateActiveTab({ output: JSON.stringify(parsed) });
    } catch (e) {
      updateActiveTab({ output: 'Error: ' + e.message });
    }
  }, [activeTab.input, parseResult, updateActiveTab]);

  const handleCopy = useCallback(async (text) => {
    try {
      await navigator.clipboard.writeText(text);
    } catch (e) {
      console.error('Failed to copy:', e);
    }
  }, []);

  const handleClear = useCallback(() => {
    updateActiveTab({ input: '', output: '', foldedLines: new Set() });
  }, [updateActiveTab]);

  const handleFontSizeChange = useCallback((e) => {
    const size = parseInt(e.target.value, 10);
    if (size >= 10 && size <= 32) {
      updateActiveTab({ fontSize: size });
    }
  }, [updateActiveTab]);

  const handleKeyDown = useCallback((e) => {
    if (e.ctrlKey && e.key === 'Enter') {
      e.preventDefault();
      handleFormat();
    }
    if (e.ctrlKey && e.key === 'a') {
      e.preventDefault();
      const target = e.target;
      target.select();
    }
  }, [handleFormat]);

  const addTab = useCallback(() => {
    const newTab = {
      id: createId(),
      name: '标签 ' + (tabs.length + 1),
      input: '',
      output: '',
      fontSize: activeTab.fontSize,
      foldedLines: new Set()
    };
    setTabs(prev => [...prev, newTab]);
    setActiveTabId(newTab.id);
  }, [tabs.length, activeTab.fontSize]);

  const closeTab = useCallback((e, tabId) => {
    e.stopPropagation();
    if (tabs.length <= 1) return;
    const newTabs = tabs.filter(t => t.id !== tabId);
    setTabs(newTabs);
    if (activeTabId === tabId && newTabs.length > 0) {
      setActiveTabId(newTabs[0].id);
    }
  }, [tabs, activeTabId]);

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 flex gap-2 p-1 overflow-hidden">
        <Card className="flex-1 flex flex-col min-w-0">
          <CardHeader className="flex-shrink-0 py-1 px-2">
            <div className="flex items-center justify-between">
              <CardTitle className="text-xs font-medium flex items-center gap-1">
                <FileJson className="w-3 h-3" />
                输入
                <span className="text-muted-foreground text-[10px] font-normal">{activeTab.input.length}</span>
              </CardTitle>
              <div className="flex items-center gap-0.5">
                <Button variant="outline" size="sm" onClick={handleFormat} className="h-5 px-1.5 text-[10px]">格式化</Button>
                <Button variant="outline" size="sm" onClick={handleCompress} className="h-5 px-1.5 text-[10px]">压缩</Button>
                <Button variant="ghost" size="sm" onClick={() => handleCopy(activeTab.input)} className="h-5 px-1.5 text-[10px]"><Copy className="w-3 h-3" /></Button>
                <Button variant="ghost" size="sm" onClick={handleClear} className="h-5 px-1.5 text-[10px]"><Trash2 className="w-3 h-3" /></Button>
              </div>
            </div>
          </CardHeader>
          <CardContent className="flex-1 py-0 px-1">
            <textarea
              value={activeTab.input}
              onChange={(e) => updateActiveTab({ input: e.target.value })}
              onKeyDown={handleKeyDown}
              className="w-full h-full resize-none border rounded p-1.5 font-mono text-xs bg-muted/20 focus:outline-none focus:ring-1 focus:ring-primary"
              style={{ fontSize: activeTab.fontSize, lineHeight: '1.3' }}
              placeholder="在此粘贴 JSON..."
            />
          </CardContent>
          <CardFooter className="flex-shrink-0 py-1 px-2 border-t">
            <div className="flex items-center gap-0.5 overflow-x-auto">
              {tabs.map(tab => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTabId(tab.id)}
                  className={'flex items-center gap-0.5 px-2 py-0.5 text-xs rounded transition-colors ' + (tab.id === activeTabId ? 'bg-primary text-primary-foreground' : 'hover:bg-muted text-muted-foreground')}
                >
                  <span className="truncate max-w-[60px]">{tab.name}</span>
                  <X className="w-2.5 h-2.5 hover:text-destructive cursor-pointer opacity-60 hover:opacity-100" onClick={(e) => closeTab(e, tab.id)} />
                </button>
              ))}
              <button onClick={addTab} className="flex items-center justify-center w-5 h-5 rounded hover:bg-muted transition-colors">
                <Plus className="w-3 h-3" />
              </button>
            </div>
          </CardFooter>
        </Card>

        <Card className="flex-1 flex flex-col min-w-0">
          <CardHeader className="flex-shrink-0 py-1 px-2">
            <CardTitle className="text-xs font-medium flex items-center gap-1">
              <ArrowDownUp className="w-3 h-3" />
              结果
              <span className="text-muted-foreground text-[10px] font-normal">{flatNodes.lineCount} 行</span>
            </CardTitle>
          </CardHeader>
          <CardContent className="flex-1 py-0 px-1 overflow-auto">
            {flatNodes.nodes.length > 0 ? (
              <div className="font-mono text-xs" style={{ fontSize: activeTab.fontSize }}>
                {flatNodes.nodes.map((node, idx) => {
                  if (!node) return null;
                  if (!isLineVisible(idx)) return null;
                  
                  const isFolded = activeTab.foldedLines.has(idx);
                  const canFold = node.isContainer && node.startBracket !== undefined;
                  
                  return (
                    <div key={idx} className="flex items-start whitespac
